<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UX Audio Router</title>
    <style>
        :root {
            --bg-body: #1a1a1a;
            --bg-panel: #2a2a2a;
            --bg-strip: #333333;
            --accent-orange: #ff9500;
            --accent-green: #4cd964;
            --accent-red: #ff3b30;
            --accent-blue: #0a84ff; /* UX Music Color */
            --text-main: #e0e0e0;
            --text-dim: #888;
        }

        body {
            font-family: "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        h1 { margin: 0 0 10px 0; font-size: 1.2rem; color: var(--text-dim); text-transform: uppercase; letter-spacing: 2px; }

        /* Connection Status Indicator */
        .status-bar {
            font-size: 0.7rem;
            color: #555;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .status-dot { width: 8px; height: 8px; border-radius: 50%; background-color: #444; }
        .status-dot.connected { background-color: var(--accent-blue); box-shadow: 0 0 8px var(--accent-blue); }

        .mixer-console {
            display: flex;
            gap: 12px;
            background-color: var(--bg-panel);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            border: 1px solid #444;
            max-height: 90vh;
            overflow-y: auto;
        }

        .strip {
            background-color: var(--bg-strip);
            width: 110px;
            border-radius: 4px;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px 5px;
            border: 1px solid #000;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.3);
            position: relative;
        }

        .strip-header { font-size: 0.9rem; font-weight: bold; margin-bottom: 8px; text-align: center; width: 100%;}
        
        .strip.input-strip { border: 1px solid var(--accent-orange); }
        .strip.input-strip .strip-header { color: var(--accent-orange); }

        /* UX Music Direct Strip Style */
        .strip.direct-strip { border: 1px solid var(--accent-blue); background: #222e3a; }
        .strip.direct-strip .strip-header { color: var(--accent-blue); }

        select {
            width: 95%; background: #222; color: white; border: 1px solid #555;
            font-size: 0.7rem; margin-bottom: 10px; border-radius: 3px;
        }

        .eq-section {
            width: 90%; background: rgba(0,0,0,0.2); padding: 5px; border-radius: 4px; margin-bottom: 10px;
            display: flex; flex-direction: column; gap: 5px;
        }
        .eq-label { font-size: 0.6rem; color: #aaa; text-align: center; margin-bottom: 2px;}
        .eq-control { display: flex; align-items: center; justify-content: space-between; font-size: 0.6rem; }
        .eq-slider { width: 70%; height: 4px; -webkit-appearance: none; background: #555; border-radius: 2px; outline: none; }
        .eq-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 10px; height: 10px; background: #ddd; border-radius: 50%; cursor: pointer; }

        .fader-track {
            flex-grow: 1; display: flex; justify-content: center; align-items: center; width: 100%;
            margin: 5px 0; background: #222; border-radius: 4px; padding: 10px 0; border: 1px inset #111; min-height: 150px;
        }

        input[type=range][orient=vertical] {
            writing-mode: bt-lr; -webkit-appearance: slider-vertical; width: 30px; height: 100%; outline: none; background: transparent;
        }

        .db-display { font-family: monospace; font-size: 0.7rem; color: var(--accent-green); margin-top: 5px; }

        .btn-mute {
            width: 80%; padding: 8px 0; background-color: #444; border: 1px solid #222;
            color: #aaa; font-size: 0.8rem; font-weight: bold; cursor: pointer; border-radius: 4px; margin-top: 10px;
        }
        .btn-mute.active { background-color: var(--accent-red); color: white; border-color: #bd2c00; }

        .add-strip-btn {
            width: 40px; background: transparent; border: 2px dashed #555; color: #555; font-size: 2rem;
            cursor: pointer; border-radius: 8px; display: flex; align-items: center; justify-content: center;
        }
        .add-strip-btn:hover { border-color: var(--accent-green); color: var(--accent-green); }
    </style>
</head>
<body>

    <h1>UX Audio Router</h1>
    
    <div class="status-bar">
        <div class="status-dot" id="uxMusicStatusDot"></div>
        <span id="uxMusicStatusText">UX Music: Disconnected</span>
    </div>

    <div class="mixer-console">
        <div class="strip input-strip">
            <div class="strip-header">HARDWARE</div>
            <div style="font-size:0.7rem; color:#888; margin-bottom:5px;">System/Mic</div>
            <select id="inputDeviceSelect"><option>Loading...</option></select>
            
            <div class="fader-track">
                <input type="range" id="inputGainFader" orient="vertical" min="0" max="1.5" step="0.01" value="1.0">
            </div>
            <div class="db-display" id="inputDbDisplay">0.0dB</div>

            <button id="startBtn" class="btn-mute" style="background-color: var(--accent-green); color: black;">ON</button>
        </div>

        <div class="strip direct-strip">
            <div class="strip-header">UX MUSIC</div>
            <div style="font-size:0.7rem; color:#888; margin-bottom:5px;">Direct Link</div>
            
            <div style="height: 25px; display:flex; align-items:center; justify-content:center; font-size:0.6rem; color:var(--accent-blue);">
                IPC SOCKET
            </div>
            
            <div class="fader-track">
                <input type="range" id="directGainFader" orient="vertical" min="0" max="1.5" step="0.01" value="1.0">
            </div>
            <div class="db-display" id="directDbDisplay">0.0dB</div>

            <button id="directMuteBtn" class="btn-mute">Mute</button>
        </div>

        <div id="outputStripsContainer" style="display:flex; gap:12px;"></div>

        <button class="add-strip-btn" id="addStripBtn" title="Add Output Device">+</button>
    </div>

<script>
    const { ipcRenderer } = require('electron');
    const net = require('net');
    const fs = require('fs');
    const os = require('os');
    const path = require('path');

    // --- Global State ---
    let inputStream = null; // Hardware Input
    let inputDeviceId = null;
    let isRunning = false;
    
    // Direct Audio Link State
    let directServer = null;
    let directSocket = null;
    let nextStartTime = 0; // For scheduling
    
    // アダプティブサンプリングレート管理
    let currentSampleRate = 44100; // デフォルト (ハンドシェイクで上書きされる)
    let isHeaderReceived = false;  // ヘッダーを受信済みか
    let headerBuffer = Buffer.alloc(0); // ヘッダー用の一時バッファ
    
    // Outputs array
    let outputs = [];
    let outputIdCounter = 1;

    // --- UI Elements ---
    const inputDeviceSelect = document.getElementById('inputDeviceSelect');
    const startBtn = document.getElementById('startBtn');
    const addStripBtn = document.getElementById('addStripBtn');
    const outputStripsContainer = document.getElementById('outputStripsContainer');
    const uxMusicStatusDot = document.getElementById('uxMusicStatusDot');
    const uxMusicStatusText = document.getElementById('uxMusicStatusText');
    
    // Hardware Input Gain UI
    const inputGainFader = document.getElementById('inputGainFader');
    const inputDbDisplay = document.getElementById('inputDbDisplay');
    let hardwareInputGainValue = 1.0;

    // Direct Input Gain UI
    const directGainFader = document.getElementById('directGainFader');
    const directDbDisplay = document.getElementById('directDbDisplay');
    const directMuteBtn = document.getElementById('directMuteBtn');
    let directInputGainValue = 1.0;
    let directInputMuted = false;

    // --- Persistence Logic ---
    function saveSettings() {
        const settings = {
            inputDeviceId: inputDeviceSelect.value,
            hardwareGain: hardwareInputGainValue,
            directGain: directInputGainValue,
            directMuted: directInputMuted,
            outputs: outputs.map(out => ({
                id: out.id,
                selectedDeviceId: out.selectedDeviceId,
                volume: out.volume,
                isMuted: out.isMuted,
                eq: out.eqValues
            }))
        };
        localStorage.setItem('uxAudioRouterSettings', JSON.stringify(settings));
    }

    function loadSettings() {
        try {
            return JSON.parse(localStorage.getItem('uxAudioRouterSettings'));
        } catch (e) { return null; }
    }

    // --- IPC Handlers (Tray) ---
    ipcRenderer.on('toggle-global-mute', () => {
        const anyActive = outputs.some(o => !o.isMuted);
        const newState = anyActive;
        outputs.forEach(out => {
            out.isMuted = newState;
            updateMuteState(out);
        });
        saveSettings();
        ipcRenderer.send('mute-status-changed', newState);
    });

    function checkGlobalMuteStatus() {
        const allMuted = outputs.every(o => o.isMuted);
        ipcRenderer.send('mute-status-changed', allMuted);
    }

    // --- Initialisation ---
    async function init() {
        await refreshDevices();
        const settings = loadSettings();

        if (settings) {
            if (settings.inputDeviceId) {
                const exists = [...inputDeviceSelect.options].some(o => o.value === settings.inputDeviceId);
                if (exists) inputDeviceSelect.value = settings.inputDeviceId;
            }
            if (settings.hardwareGain !== undefined) {
                hardwareInputGainValue = settings.hardwareGain;
                inputGainFader.value = hardwareInputGainValue;
                updateDbDisplay(inputDbDisplay, hardwareInputGainValue);
            }
            if (settings.directGain !== undefined) {
                directInputGainValue = settings.directGain;
                directGainFader.value = directInputGainValue;
                updateDbDisplay(directDbDisplay, directInputGainValue);
            }
            if (settings.directMuted !== undefined) {
                directInputMuted = settings.directMuted;
                updateDirectMuteUI();
            }

            if (settings.outputs && settings.outputs.length > 0) {
                let maxId = 0;
                settings.outputs.forEach(savedData => {
                    addOutputStrip(savedData);
                    if (savedData.id > maxId) maxId = savedData.id;
                });
                outputIdCounter = maxId + 1;
            } else { addOutputStrip(); }
        } else { addOutputStrip(); }
        
        checkGlobalMuteStatus();
        startDirectAudioServer(); // Start the IPC Server
    }

    // --- Direct Audio Link Server (IPC) ---
    function startDirectAudioServer() {
        const isWin = process.platform === 'win32';
        const SOCKET_PATH = isWin 
            ? '\\\\.\\pipe\\ux_audio_router_pipe' 
            : '/tmp/ux_audio_router.sock';

        // Cleanup for Unix sockets
        if (!isWin && fs.existsSync(SOCKET_PATH)) {
            try { fs.unlinkSync(SOCKET_PATH); } catch(e) {}
        }

        directServer = net.createServer((socket) => {
            console.log('UX Music Connected (Socket Opened)');
            updateStatusUI(false); // まだハンドシェイク前なのでDisconnected扱い
            directSocket = socket;
            
            // 新しい接続のたびにリセット
            isHeaderReceived = false;
            headerBuffer = Buffer.alloc(0);

            socket.on('data', (buffer) => {
                if (!isRunning) return;

                // --- ヘッダーハンドシェイク処理 ---
                if (!isHeaderReceived) {
                    // ヘッダーが分割されて届く可能性を考慮して結合
                    headerBuffer = Buffer.concat([headerBuffer, buffer]);
                    
                    if (headerBuffer.length >= 8) {
                        // 先頭4バイト: Magic 'UXD1'
                        const magic = headerBuffer.slice(0, 4).toString();
                        if (magic === 'UXD1') {
                            // 次の4バイト: サンプリングレート (UInt32 LE)
                            currentSampleRate = headerBuffer.readUInt32LE(4);
                            console.log(`[Handshake] UX Music Header Received. Rate: ${currentSampleRate}Hz`);
                            
                            isHeaderReceived = true;
                            updateStatusUI(true, currentSampleRate);

                            // 残りのデータがあれば音声として処理
                            const remaining = headerBuffer.slice(8);
                            if (remaining.length > 0) {
                                processAudioPacket(remaining);
                            }
                        } else {
                            console.error('Invalid Header Magic:', magic);
                            socket.destroy();
                        }
                        // ヘッダー用バッファは解放
                        headerBuffer = Buffer.alloc(0);
                    }
                    return;
                }

                // ヘッダー受信後は通常音声として処理
                processAudioPacket(buffer);
            });

            socket.on('end', () => {
                console.log('UX Music Disconnected');
                updateStatusUI(false);
                directSocket = null;
            });
            
            socket.on('error', (err) => {
                console.error('Socket error:', err);
                updateStatusUI(false);
            });
        });

        directServer.listen(SOCKET_PATH, () => {
            console.log(`IPC Server listening on ${SOCKET_PATH}`);
        });

        directServer.on('error', (e) => {
            if (e.code === 'EADDRINUSE') {
                console.log('Address in use, retrying...');
                // Simple retry logic could go here
            }
        });
    }

    function updateStatusUI(isConnected, rate) {
        if (isConnected) {
            uxMusicStatusDot.classList.add('connected');
            uxMusicStatusText.textContent = `UX Music: Connected (${rate}Hz)`;
            uxMusicStatusText.style.color = "var(--accent-blue)";
        } else {
            uxMusicStatusDot.classList.remove('connected');
            uxMusicStatusText.textContent = "UX Music: Disconnected";
            uxMusicStatusText.style.color = "#555";
        }
    }

    // --- Audio Packet Processing (Raw PCM -> Web Audio) ---
    function processAudioPacket(buffer) {
        // Spec: 32-bit Float, Stereo, Interleaved -> 1 frame = 8 bytes
        if (buffer.length % 8 !== 0) {
            const alignedLen = Math.floor(buffer.length / 8) * 8;
            buffer = buffer.slice(0, alignedLen);
        }
        if (buffer.length === 0) return;

        const floatArray = new Float32Array(buffer.buffer, buffer.byteOffset, buffer.byteLength / 4);
        const frameCount = floatArray.length / 2;
        
        outputs.forEach(out => {
            if (out.context && out.directGainNode) {
                playBufferOnContext(out.context, out.directGainNode, floatArray, frameCount);
            }
        });
    }

    function playBufferOnContext(ctx, destinationNode, floatArray, frameCount) {
        // ハンドシェイクで受け取ったレートを使用
        const audioBuffer = ctx.createBuffer(2, frameCount, currentSampleRate);
        const ch0 = audioBuffer.getChannelData(0);
        const ch1 = audioBuffer.getChannelData(1);

        // De-interleave
        for (let i = 0; i < frameCount; i++) {
            ch0[i] = floatArray[i * 2];
            ch1[i] = floatArray[i * 2 + 1];
        }

        const source = ctx.createBufferSource();
        source.buffer = audioBuffer;
        source.connect(destinationNode);

        const currentTime = ctx.currentTime;
        
        // ジッターバッファ (安全マージン)
        const BUFFER_SAFE_MARGIN = 0.12; 

        if (nextStartTime < currentTime) {
            nextStartTime = currentTime + BUFFER_SAFE_MARGIN;
        }

        source.start(nextStartTime);
        nextStartTime += audioBuffer.duration;
    }


    // --- General Device Management ---
    async function refreshDevices() {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const inputs = devices.filter(d => d.kind === 'audioinput');
        const outputDevices = devices.filter(d => d.kind === 'audiooutput');

        const currentInput = inputDeviceSelect.value;
        inputDeviceSelect.innerHTML = '';
        inputs.forEach(device => {
            const opt = document.createElement('option');
            opt.value = device.deviceId;
            opt.text = cleanLabel(device.label) || `Input ${device.deviceId.slice(0,4)}`;
            if (device.label.includes('BlackHole')) opt.selected = true;
            inputDeviceSelect.appendChild(opt);
        });
        if(currentInput && inputs.some(d => d.deviceId === currentInput)) inputDeviceSelect.value = currentInput;

        window.availableOutputDevices = outputDevices;
        outputs.forEach(out => updateOutputStripDropdown(out, outputDevices));
    }

    function cleanLabel(label) {
        return label.replace(/Default - /, '').replace(/ \([0-9a-f]{4}:[0-9a-f]{4}\)/, '');
    }

    // --- Audio Engine (Hardware Input) ---
    async function startEngine() {
        if (isRunning) return;
        
        // スケジューリング時間をリセット
        nextStartTime = 0; 

        try {
            inputDeviceId = inputDeviceSelect.value;
            inputStream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    deviceId: { exact: inputDeviceId },
                    autoGainControl: false, echoCancellation: false, noiseSuppression: false,
                    channelCount: 2, sampleRate: 48000
                }
            });

            for (const out of outputs) await connectOutputEngine(out);

            isRunning = true;
            startBtn.textContent = "ACTIVE";
            startBtn.style.backgroundColor = "var(--accent-orange)";
            inputDeviceSelect.disabled = true;
        } catch (err) {
            console.error(err);
            alert("Error: " + err.message);
        }
    }

    function stopEngine() {
        if (!isRunning) return;
        outputs.forEach(out => {
            if (out.context) { out.context.close(); out.context = null; }
            out.sourceNode = null; out.hardwareGainNode = null; out.directGainNode = null;
        });
        if (inputStream) { inputStream.getTracks().forEach(t => t.stop()); inputStream = null; }
        isRunning = false;
        startBtn.textContent = "ON";
        startBtn.style.backgroundColor = "var(--accent-green)";
        inputDeviceSelect.disabled = false;
    }

    // Connects ONE output strip to both Hardware Input AND Direct Link
    async function connectOutputEngine(outputObj) {
        const ctx = new (window.AudioContext || window.webkitAudioContext)({
            latencyHint: 'interactive', sampleRate: 48000
        });

        if (outputObj.selectedDeviceId && typeof ctx.setSinkId === 'function') {
            try { await ctx.setSinkId(outputObj.selectedDeviceId); } catch (e) {}
        }

        // --- Hardware Input Chain ---
        let hardwareGain = null;
        if (inputStream) {
            const source = ctx.createMediaStreamSource(inputStream);
            hardwareGain = ctx.createGain();
            hardwareGain.gain.value = hardwareInputGainValue; // Master Hardware Gain
            source.connect(hardwareGain);
        }

        // --- Direct Link Chain ---
        const directGain = ctx.createGain();
        directGain.gain.value = directInputMuted ? 0 : directInputGainValue;

        // --- EQ & Master Output Chain ---
        const highShelf = ctx.createBiquadFilter(); highShelf.type = "highshelf"; highShelf.frequency.value = 8000; highShelf.gain.value = outputObj.eqValues.high;
        const peaking = ctx.createBiquadFilter(); peaking.type = "peaking"; peaking.frequency.value = 1000; peaking.Q.value = 1.0; peaking.gain.value = outputObj.eqValues.mid;
        const lowShelf = ctx.createBiquadFilter(); lowShelf.type = "lowshelf"; lowShelf.frequency.value = 200; lowShelf.gain.value = outputObj.eqValues.low;

        const stripVolume = ctx.createGain();
        stripVolume.gain.value = outputObj.isMuted ? 0 : outputObj.volume;

        // Mixing Logic:
        // (HardwareInput * HardwareGain) + (DirectInput * DirectGain) -> EQ -> StripVolume -> Output
        
        if (hardwareGain) hardwareGain.connect(lowShelf);
        directGain.connect(lowShelf); // Merge Direct Audio here

        lowShelf.connect(peaking);
        peaking.connect(highShelf);
        highShelf.connect(stripVolume);
        stripVolume.connect(ctx.destination);

        outputObj.context = ctx;
        outputObj.hardwareGainNode = hardwareGain; // To update hardware gain later
        outputObj.directGainNode = directGain;     // To update direct gain later
        outputObj.eqNodes = { low: lowShelf, mid: peaking, high: highShelf };
        outputObj.gainNode = stripVolume;          // Strip master volume
    }

    // --- UI Logic & Event Listeners ---

    // Hardware Input Gain Logic
    inputGainFader.addEventListener('input', (e) => {
        hardwareInputGainValue = parseFloat(e.target.value);
        updateDbDisplay(inputDbDisplay, hardwareInputGainValue);
        // Update live nodes
        outputs.forEach(out => {
            if (out.hardwareGainNode && out.context) {
                out.hardwareGainNode.gain.setTargetAtTime(hardwareInputGainValue, out.context.currentTime, 0.02);
            }
        });
    });
    inputGainFader.addEventListener('change', saveSettings);

    // Direct Input Gain Logic
    directGainFader.addEventListener('input', (e) => {
        directInputGainValue = parseFloat(e.target.value);
        updateDbDisplay(directDbDisplay, directInputGainValue);
        updateDirectNodes();
    });
    directGainFader.addEventListener('change', saveSettings);

    directMuteBtn.addEventListener('click', () => {
        directInputMuted = !directInputMuted;
        updateDirectMuteUI();
        updateDirectNodes();
        saveSettings();
    });

    function updateDirectMuteUI() {
        directMuteBtn.classList.toggle('active', directInputMuted);
        directMuteBtn.textContent = directInputMuted ? "MUTED" : "Mute";
    }

    function updateDirectNodes() {
        const target = directInputMuted ? 0 : directInputGainValue;
        outputs.forEach(out => {
            if (out.directGainNode && out.context) {
                out.directGainNode.gain.setTargetAtTime(target, out.context.currentTime, 0.02);
            }
        });
    }

    function updateDbDisplay(element, val) {
        const db = val === 0 ? -Infinity : 20 * Math.log10(val);
        element.textContent = (db === -Infinity ? "-Inf" : db.toFixed(1)) + "dB";
    }

    function addOutputStrip(savedData = null) {
        const id = savedData ? savedData.id : outputIdCounter++;
        const stripName = "A" + id;
        if (savedData && savedData.id >= outputIdCounter) outputIdCounter = savedData.id + 1;

        const initialVol = savedData ? savedData.volume : 1.0;
        const initialMute = savedData ? savedData.isMuted : false;
        const eqVals = savedData ? savedData.eq : { low: 0, mid: 0, high: 0 };

        const stripDiv = document.createElement('div');
        stripDiv.className = 'strip';
        stripDiv.innerHTML = `
            <div class="strip-header">${stripName}</div>
            <select></select>
            
            <div class="eq-section">
                <div class="eq-label">EQ</div>
                <div class="eq-control"><span>H</span> <input type="range" class="eq-slider" data-type="high" min="-15" max="15" value="${eqVals.high}"></div>
                <div class="eq-control"><span>M</span> <input type="range" class="eq-slider" data-type="mid" min="-15" max="15" value="${eqVals.mid}"></div>
                <div class="eq-control"><span>L</span> <input type="range" class="eq-slider" data-type="low" min="-15" max="15" value="${eqVals.low}"></div>
            </div>

            <div class="fader-track">
                <input type="range" class="fader-main" orient="vertical" min="0" max="1.5" step="0.01" value="${initialVol}">
            </div>
            <div class="db-display">0.0dB</div>
            <button class="btn-mute ${initialMute ? 'active' : ''}">${initialMute ? 'MUTED' : 'Mute'}</button>
        `;
        outputStripsContainer.appendChild(stripDiv);

        const outputObj = {
            id: id, div: stripDiv,
            context: null, hardwareGainNode: null, directGainNode: null, gainNode: null, eqNodes: {},
            selectedDeviceId: savedData ? savedData.selectedDeviceId : null,
            volume: initialVol, isMuted: initialMute, eqValues: eqVals
        };

        const select = stripDiv.querySelector('select');
        const fader = stripDiv.querySelector('.fader-main');
        const dbDisplay = stripDiv.querySelector('.db-display');
        const muteBtn = stripDiv.querySelector('.btn-mute');
        const eqSliders = stripDiv.querySelectorAll('.eq-slider');

        const db = initialVol === 0 ? -Infinity : 20 * Math.log10(initialVol);
        dbDisplay.textContent = (db === -Infinity ? "-Inf" : db.toFixed(1)) + "dB";
        if (window.availableOutputDevices) updateOutputStripDropdown(outputObj, window.availableOutputDevices);

        select.addEventListener('change', async (e) => {
            outputObj.selectedDeviceId = e.target.value;
            saveSettings();
            if (isRunning && outputObj.context && typeof outputObj.context.setSinkId === 'function') {
                try { await outputObj.context.setSinkId(outputObj.selectedDeviceId); } catch(err){}
            }
        });

        eqSliders.forEach(slider => {
            slider.addEventListener('input', (e) => {
                const type = e.target.dataset.type;
                const val = parseFloat(e.target.value);
                outputObj.eqValues[type] = val;
                if (outputObj.eqNodes && outputObj.eqNodes[type]) {
                    outputObj.eqNodes[type].gain.setTargetAtTime(val, outputObj.context.currentTime, 0.05);
                }
            });
            slider.addEventListener('change', saveSettings);
        });

        fader.addEventListener('input', (e) => {
            const val = parseFloat(e.target.value);
            outputObj.volume = val;
            updateDbDisplay(dbDisplay, val);
            if (outputObj.gainNode && !outputObj.isMuted) {
                outputObj.gainNode.gain.setTargetAtTime(val, outputObj.context.currentTime, 0.02);
            }
        });
        fader.addEventListener('change', saveSettings);

        muteBtn.addEventListener('click', () => {
            outputObj.isMuted = !outputObj.isMuted;
            muteBtn.classList.toggle('active', outputObj.isMuted);
            muteBtn.textContent = outputObj.isMuted ? "MUTED" : "Mute";
            if (outputObj.gainNode && outputObj.context) {
                const targetVol = outputObj.isMuted ? 0 : outputObj.volume;
                outputObj.gainNode.gain.setTargetAtTime(targetVol, outputObj.context.currentTime, 0.02);
            }
            saveSettings();
            checkGlobalMuteStatus();
        });

        outputs.push(outputObj);
        if (isRunning) connectOutputEngine(outputObj);
        saveSettings();
    }

    function updateOutputStripDropdown(outputObj, devices) {
        const select = outputObj.div.querySelector('select');
        const currentVal = outputObj.selectedDeviceId;
        select.innerHTML = '<option value="">Select Device...</option>';
        devices.forEach(d => {
            const opt = document.createElement('option');
            opt.value = d.deviceId;
            opt.text = cleanLabel(d.label);
            select.appendChild(opt);
        });
        if (currentVal) select.value = currentVal;
    }

    inputDeviceSelect.addEventListener('change', saveSettings);
    startBtn.addEventListener('click', () => { if (isRunning) stopEngine(); else startEngine(); });
    addStripBtn.addEventListener('click', () => addOutputStrip());
    navigator.mediaDevices.ondevicechange = refreshDevices;

    init();
</script>
</body>
</html>